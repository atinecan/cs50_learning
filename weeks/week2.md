# CS50 – Week 2: Algorithms and Problem Solving

## 1. What is an Algorithm?

An algorithm is a step-by-step procedure for solving a problem.
In this week, I learned that algorithms are not specific to computers —
they are precise ways of thinking that can be executed by machines.

What surprised me was that different algorithms can solve the same problem,
but with very different levels of efficiency.

---

## 2. Measuring Efficiency: Time Complexity (Conceptual)

One key idea introduced is that not all solutions are equally efficient.
Some algorithms scale better as the input size increases.

Examples discussed in the lecture include:
- Linear search
- Binary search

Even without formal mathematical notation, I started to understand the intuition:
an algorithm that checks fewer possibilities will usually perform better.

At this stage, I focus more on understanding *why* one approach is faster than another,
rather than memorizing formulas.

---

## 3. Linear Search vs. Binary Search

### Linear Search
- Checks each element one by one
- Simple to understand
- Works on unsorted data
- Can be slow for large inputs

### Binary Search
- Requires sorted data
- Repeatedly divides the problem in half
- Much faster for large datasets

This comparison helped me realize how important problem constraints are.
Choosing an algorithm depends not only on speed, but also on the structure of the data.

---

## 4. Algorithmic Thinking

This week emphasized breaking down problems into smaller, logical steps.

Instead of asking:
> “How do I write the code?”

I learned to first ask:
> “What are the exact steps needed to solve this problem?”

This shift in thinking feels similar to constructing an argument in philosophy:
clarify assumptions, define steps, and follow them consistently.

---

## 5. Challenges and Difficulties

Some difficulties I encountered this week:
- Understanding abstract performance comparisons without concrete numbers
- Getting used to thinking in terms of procedures rather than outcomes
- Following algorithm explanations in technical English

I often needed to pause the lecture and replay certain explanations,
especially when new terminology was introduced.

---

## 6. Personal Reflection

Week 2 made me more aware that computer science is fundamentally about structure and clarity.
Writing down algorithms in plain language before coding helped reduce confusion.

Although I am still at an early stage,
I feel that this way of thinking is gradually becoming more natural to me.
